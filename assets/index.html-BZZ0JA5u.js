import{a,c as i,b as n,o as e}from"./app-C7AwxLk6.js";const t={};function l(r,s){return e(),i("div",null,s[0]||(s[0]=[n(`<h3 id="ford-fulkerson-algorithm" tabindex="-1"><a class="header-anchor" href="#ford-fulkerson-algorithm"><span>Ford-Fulkerson Algorithm</span></a></h3><div class="hint-container note"><p class="hint-container-title">Algorithm Complexity</p><p><strong>Time Complexity:</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>F</mi><mo>⋅</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(F \\cdot E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is the maximum flow and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is the number of edges</p></div><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">def</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ford_fulkerson</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">my_graph</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    # initialzie flow</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    flow </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    # initialize the residual network</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    residual_network </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ResidualNetwork</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">my_graph</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    # as long s there is a augmenting path</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    while</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> residual_network</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">has_AugmentingPath</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">():</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        # take the path</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        path </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> residual_network</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">get_AugmentingPath</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        # augment the flow equal to the residual capacity</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        flow </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">+=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> path</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">residual_capacity</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        # updating the residual network</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        residual_network</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">augmentFlow</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">path</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> flow</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="the-residual-network" tabindex="-1"><a class="header-anchor" href="#the-residual-network"><span>The Residual Network</span></a></h4><p>Given a flow network, G = (V, E) and a flow f, the residual network G_f, essentially represents how much more flow can be sent through each edge.</p><div class="hint-container tip"><p class="hint-container-title">Key Properties</p><ul><li><strong>Same vertices</strong> as original network</li><li><strong>Forward edge</strong> / residual edge for <mark>remaining capacity</mark></li><li><strong>Backward edge</strong> / reversible edge for flow that can be <mark>cancelled</mark></li><li><strong>Simple graph</strong>, so multi edges are merged together</li><li>Sum of the edges between 2 vertices same as the edge capacity</li></ul></div><h4 id="path-augmentation" tabindex="-1"><a class="header-anchor" href="#path-augmentation"><span>Path Augmentation</span></a></h4><div class="hint-container important"><p class="hint-container-title">Augmenting Path</p><ul><li>A <strong>traversal</strong> in the residual network <ul><li>from <strong>source</strong> to <strong>target</strong></li></ul></li><li>Following the edges in the residual network</li></ul></div><h3 id="minimum-cut" tabindex="-1"><a class="header-anchor" href="#minimum-cut"><span>Minimum Cut</span></a></h3><div class="hint-container warning"><p class="hint-container-title">TODO</p><p>Content to be added - relationship between max flow and min cut</p></div><h3 id="bipartite-matching-problem" tabindex="-1"><a class="header-anchor" href="#bipartite-matching-problem"><span>Bipartite Matching Problem</span></a></h3><div class="hint-container warning"><p class="hint-container-title">TODO</p><p>Content to be added - reducing bipartite matching to max flow</p></div><h3 id="circulations-with-demands-and-lower-bounds" tabindex="-1"><a class="header-anchor" href="#circulations-with-demands-and-lower-bounds"><span>Circulations with Demands and Lower Bounds</span></a></h3><div class="hint-container warning"><p class="hint-container-title">TODO</p><p>Content to be added - handling flow networks with constraints</p></div><h2 id="search-trees" tabindex="-1"><a class="header-anchor" href="#search-trees"><span>Search Trees</span></a></h2><div class="hint-container info"><p class="hint-container-title">Tree Data Structures Overview</p><p>The following tree structures are commonly used in computer science:</p></div><ul><li><strong>Binary Search Trees</strong> - Basic ordered tree structure</li><li><strong>AVL Trees</strong> - Self-balancing BST with height balancing</li><li><strong>2-3 Trees</strong> - Multi-way search trees with 2 or 3 children</li><li><strong>Red-Black Trees</strong> - Self-balancing BST with color properties</li><li><strong>Prefix Trie</strong> - Tree for storing strings with common prefixes</li><li><strong>Suffix Tree</strong> - Compressed trie for all suffixes of a string</li><li><strong>Suffix Array</strong> - Space-efficient alternative to suffix trees</li></ul>`,17)]))}const p=a(t,[["render",l]]),o=JSON.parse('{"path":"/fit2004/nid5kahg/","title":"Network Flow","lang":"en-US","frontmatter":{"title":"Network Flow","createTime":"2025/06/06 11:21:13","permalink":"/fit2004/nid5kahg/"},"readingTime":{"minutes":3.86,"words":309},"git":{"createdTime":1754307634000,"updatedTime":1754307634000,"changelog":[{"hash":"a20312923d4f06c06ebcc0004fa11ecb45d01e77","time":1754307634000,"email":"yunfeng.long@yahoo.com","author":"WARREN Y.F. LONG","message":"feat: add new notes for FIT3080 and FIT2004, including algorithms and time complexity concepts"}]},"filePathRelative":"notes/fit2004/revision/7.network_flow.md","headers":[]}');export{p as comp,o as data};
