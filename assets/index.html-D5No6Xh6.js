import{a,c as t,b as s,o as r}from"./app-C7AwxLk6.js";const o={};function n(i,e){return r(),t("div",null,e[0]||(e[0]=[s('<h3 id="_1-how-would-you-classify-a-modern-web-server-using-flynn-s-taxonomy" tabindex="-1"><a class="header-anchor" href="#_1-how-would-you-classify-a-modern-web-server-using-flynn-s-taxonomy"><span><strong>1. How would you classify a modern web server using Flynn&#39;s Taxonomy?</strong></span></a></h3><p>A modern web server is best described as a <strong>MIMD (Multiple Instruction, Multiple Data)</strong> system. This is because a web server handles many user requests at the same time, with each user potentially performing a different task (e.g., one user searching, another posting a comment). This corresponds to multiple, independent instruction streams acting on multiple, different data streams.</p><h3 id="_2-which-of-flynn-s-classifications-would-be-best-for-applying-the-same-filter-to-thousands-of-images" tabindex="-1"><a class="header-anchor" href="#_2-which-of-flynn-s-classifications-would-be-best-for-applying-the-same-filter-to-thousands-of-images"><span><strong>2. Which of Flynn&#39;s classifications would be best for applying the same filter to thousands of images?</strong></span></a></h3><p>The most efficient classification for this hardware would be <strong>SIMD (Single Instruction, Multiple Data)</strong>. The task involves applying one identical operation (the &quot;single instruction&quot;) to a vast number of different data elements (the &quot;multiple data&quot; of the images) all at once. This architecture is highly efficient for problems with a high degree of regularity, like image processing.</p><h3 id="_3-what-memory-architecture-does-a-supercomputer-made-of-networked-multi-core-nodes-use" tabindex="-1"><a class="header-anchor" href="#_3-what-memory-architecture-does-a-supercomputer-made-of-networked-multi-core-nodes-use"><span><strong>3. What memory architecture does a supercomputer made of networked, multi-core nodes use?</strong></span></a></h3><p>This system uses a <strong>Hybrid Memory Architecture</strong>.</p><ul><li><strong>Shared Memory</strong>: At the node level, the multiple cores within a single machine can access that machine&#39;s memory as a global, shared resource.</li><li><strong>Distributed Memory</strong>: The thousands of nodes are connected by a network. To share data between different nodes, network communication is required because one node cannot directly access the memory of another.</li></ul><h3 id="_4-is-a-master-slave-facial-recognition-program-an-example-of-spmd-or-mpmd" tabindex="-1"><a class="header-anchor" href="#_4-is-a-master-slave-facial-recognition-program-an-example-of-spmd-or-mpmd"><span><strong>4. Is a master-slave facial recognition program an example of SPMD or MPMD?</strong></span></a></h3><p>This structure is best described as <strong>MPMD (Multiple Program, Multiple Data)</strong>. While the slave processors all run the same program, the master processor runs a <em>different</em> program responsible for distributing the work. Since the master&#39;s program and the slaves&#39; program are different, MPMD is the more accurate description.</p><h3 id="_5-what-is-the-main-challenge-of-using-a-distributed-memory-architecture-for-an-application-that-needs-a-large-shared-data-table" tabindex="-1"><a class="header-anchor" href="#_5-what-is-the-main-challenge-of-using-a-distributed-memory-architecture-for-an-application-that-needs-a-large-shared-data-table"><span><strong>5. What is the main challenge of using a distributed memory architecture for an application that needs a large, shared data table?</strong></span></a></h3><p>On a distributed memory system, the primary challenge would be the <strong>lack of a global address space</strong>. Unlike a shared memory system where any processor can directly access the table, a distributed system gives each processor its own private memory. Therefore, if a processor needs to read or update data held in another processor&#39;s memory, the programmer must explicitly write code to manage that communication over the network, adding significant complexity and requiring careful synchronization.</p>',11)]))}const c=a(o,[["render",n]]),h=JSON.parse('{"path":"/fit3143/ehkolxh2/","title":"Application","lang":"en-US","frontmatter":{"title":"Application","createTime":"2025/08/02 17:36:31","permalink":"/fit3143/ehkolxh2/"},"readingTime":{"minutes":4.96,"words":397},"git":{"createdTime":1754146040000,"updatedTime":1754146040000,"changelog":[{"hash":"38fa9a6d0a743a0a4735de8761312f7220e0f7dc","time":1754146040000,"email":"yunfeng.long@yahoo.com","author":"wanfunglung","message":"feat: add new notes on parallel architectures, applications, and IPC mechanisms"}]},"filePathRelative":"notes/fit3143/introduction/application.md","headers":[]}');export{c as comp,h as data};
