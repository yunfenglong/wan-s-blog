import{a as u,c as d,d as t,e as a,f as e,w as o,r as s,o as m}from"./app-C7AwxLk6.js";const c={},f={class:"vp-field-group"};function p(h,n){const i=s("VPCard"),l=s("VPCardGrid"),r=s("VPField");return m(),d("div",null,[n[9]||(n[9]=t("div",{class:"hint-container note"},[t("p",{class:"hint-container-title"},"Note"),t("p",null,[e("Functional Programming (FP) is a programming paradigm built around the concept of "),t("mark",null,"composable functions"),e(" as the primary unit of composition. Rather than focusing on objects and the state they contain, FP treats programming as a process of data "),t("mark",null,"transformation"),e(', where functions act as the "verbs" that drive the computation.')])],-1)),n[10]||(n[10]=t("h3",{id:"core-concepts-of-functional-programming",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#core-concepts-of-functional-programming"},[t("span",null,"Core Concepts of Functional Programming")])],-1)),n[11]||(n[11]=t("p",null,"Functional programming is defined by a few key principles that differentiate it from other paradigms like Object-Oriented programming.",-1)),a(l,null,{default:o(()=>[a(i,{title:"A Kingdom of Verbs",icon:"mdi:run-fast"},{default:o(()=>n[0]||(n[0]=[t("p",null,[e("Functional programming focuses on functions as "),t("em",null,"transformations"),e(' of data. This approach is often described as a "Kingdom of Verbs," where the primary focus is on the actions (functions) rather than the static data structures ("nouns").')],-1)])),_:1,__:[0]}),a(i,{title:"Purity and Immutability",icon:"mdi:shield-check-outline"},{default:o(()=>n[1]||(n[1]=[t("p",null,[e("FP adheres closely to the mathematical definition of a function. This means functions should be "),t("em",null,"pure"),e("â€”their only result is an explicit return value, and they have no hidden "),t("em",null,"side effects"),e(" (like modifying external state). As part of this, FP favors treating data as immutable.")],-1)])),_:1,__:[1]}),a(i,{title:"Declarative Style",icon:"mdi:lightbulb-on-outline"},{default:o(()=>n[2]||(n[2]=[t("p",null,[e("Pure functional programs tend to be more declarative, focusing on "),t("mark",null,"what"),e(" the solution is rather than "),t("mark",null,"how"),e(" to compute it step-by-step. The manipulation of state is made explicit through function parameters and return types instead of being hidden in side effects.")],-1)])),_:1,__:[2]}),a(i,{title:"Higher-Order Functions",icon:"mdi:function-variant"},{default:o(()=>n[3]||(n[3]=[t("p",null,[e("A central feature of FP is the support for "),t("em",null,"higher-order functions"),e(". These are functions that can take other functions as arguments or return new functions as their result, enabling powerful patterns of abstraction and composition.")],-1)])),_:1,__:[3]})]),_:1}),n[12]||(n[12]=t("h3",{id:"the-foundation-lambda-calculus",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#the-foundation-lambda-calculus"},[t("span",null,"The Foundation: Lambda Calculus")])],-1)),a(i,{title:"Model of Computation",icon:"mdi:calculator-variant-outline"},{default:o(()=>n[4]||(n[4]=[t("p",null,[e("The functional paradigm is not based on the underlying machine architecture but on a different model of computation entirely: the "),t("strong",null,"Lambda Calculus"),e(". Developed in the 1930s, this model is based on mathematical functions, their application, and their composition.")],-1)])),_:1,__:[4]}),n[13]||(n[13]=t("h3",{id:"key-characteristics-of-functional-programming",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#key-characteristics-of-functional-programming"},[t("span",null,"Key Characteristics of Functional Programming")])],-1)),n[14]||(n[14]=t("p",null,"The principles of FP lead to a distinct set of characteristics, especially when compared to the Object-Oriented paradigm.",-1)),t("div",f,[a(r,{name:"State Management",type:"Immutable"},{default:o(()=>n[5]||(n[5]=[t("p",null,"FP treats objects as immutable. Instead of mutating an object's state, a function returns a new object with the updated state.",-1)])),_:1,__:[5]}),a(r,{name:"Data and Behaviour",type:"Loosely Coupled"},{default:o(()=>n[6]||(n[6]=[t("p",null,"Data and the functions that operate on it are loosely coupled. This is achieved through pure, generic functions that are not tied to a specific object's internal state.",-1)])),_:1,__:[6]}),a(r,{name:"Control Flow",type:"Function-based"},{default:o(()=>n[7]||(n[7]=[t("p",null,"Control flow is managed through function calls, recursion, and the chaining of functions, rather than traditional loops and conditionals.",-1)])),_:1,__:[7]}),a(r,{name:"Thread Safety",type:"Concurrent by Nature"},{default:o(()=>n[8]||(n[8]=[t("p",null,"Because pure functions do not modify external state, they are easily and safely used in concurrent or parallel computations without the risk of race conditions.",-1)])),_:1,__:[8]})]),n[15]||(n[15]=t("div",{class:"hint-container tip"},[t("p",{class:"hint-container-title"},"Modern Functional Programming"),t("p",null,"Historically, Functional and Object-Oriented programming were seen as competing paradigms. However, they are now viewed as complementary. Many modern languages, including TypeScript, Scala, C++17, Java (8+), Swift, Rust, and Python 3, provide facilities for both, allowing programmers to use functional concepts to write more robust and maintainable code.")],-1))])}const b=u(c,[["render",p]]),y=JSON.parse('{"path":"/programming-paradigm/1i4j4e2w/","title":"Introduction to Functional Programming","lang":"en-US","frontmatter":{"title":"Introduction to Functional Programming","createTime":"2025/08/05 11:29:14","permalink":"/programming-paradigm/1i4j4e2w/"},"readingTime":{"minutes":6.83,"words":546},"git":{"createdTime":1754402412000,"updatedTime":1754402412000,"changelog":[{"hash":"7cf8ded3dddc2ababaf9819f8a5fc508a75a8b9f","time":1754402412000,"email":"yunfeng.long@yahoo.com","author":"WARREN Y.F. LONG","message":"feat: add introductory notes on Functional Programming and Levels of Abstraction"}]},"filePathRelative":"notes/programming-paradigm/func_program/1.basic.md","headers":[]}');export{b as comp,y as data};
