import{a as f,c as b,b as d,d as e,e as a,w as o,f as n,r as i,o as h}from"./app-C7AwxLk6.js";const y={},x={class:"vp-field-group"};function v(w,t){const u=i("VPField"),s=i("VPIcon"),l=i("Annotation"),m=i("VPTimelineItem"),p=i("VPTimeline"),r=i("VPCollapseItem"),g=i("VPCollapse");return h(),b("div",null,[t[60]||(t[60]=d('<p>This document explores the evolution of programming languages as tools that create layers of abstraction over computer hardware. The goal is to move from low-level machine operations to high-level, human-understandable programs. Key concepts include the difference between <mark>syntax</mark> and <mark>semantics</mark>, various <mark>models of computation</mark>, and the <mark>dominant programming paradigms</mark> that shape how we solve problems.</p><hr><h3 id="syntax-vs-semantics" tabindex="-1"><a class="header-anchor" href="#syntax-vs-semantics"><span>Syntax vs. Semantics</span></a></h3><p>A foundational concept in programming languages is the distinction between <em>what a program looks like</em> and <em>what a program means</em>.</p>',4)),e("div",x,[a(u,{name:"Syntax",type:"string"},{default:o(()=>t[0]||(t[0]=[e("p",null,[n("The symbols, grammar, and structural rules that define a correctly written program. It's about the "),e("mark",null,"form"),n(". For example, using "),e("code",null,"{}"),n(" versus indentation for code blocks is a syntactic choice.")],-1)])),_:1,__:[0]}),a(u,{name:"Semantics",type:"string"},{default:o(()=>t[1]||(t[1]=[e("p",null,[n("The meaning of a program and the computational processes it follows when executed. It's about the "),e("mark",null,"function and meaning"),n(". For example, two functions in different languages can be syntactically different but semantically identical if they compute the same result.")],-1)])),_:1,__:[1]})]),t[61]||(t[61]=e("hr",null,null,-1)),t[62]||(t[62]=e("h3",{id:"models-of-computation",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#models-of-computation"},[e("span",null,"Models of Computation")])],-1)),t[63]||(t[63]=e("p",null,"Different programming paradigms are built upon different conceptual models of how a computer works.",-1)),a(p,{card:void 0},{default:o(()=>[a(m,{time:"1930s",icon:"mdi:tape-drive",card:void 0},{icon:o(()=>[a(s,{provider:"iconify",name:"mdi:tape-drive"})]),title:o(()=>[t[3]||(t[3]=e("strong",null,"Turing Machines",-1)),t[4]||(t[4]=n()),a(l,{label:"TuringMachine",total:1},{"item-0":o(()=>t[2]||(t[2]=[e("p",null,"A model of computation based on a hypothetical machine reading or writing instructions on a tape, which decides how to proceed based on the symbols it reads from the tape.",-1)])),_:1})]),default:o(()=>[t[5]||(t[5]=e("p",null,[n("A conceptual model using a tape-reading machine. It forms the basis of the "),e("mark",null,"imperative"),n(" paradigm of sequential instruction execution.")],-1))]),_:1,__:[5]}),a(m,{time:"1930s",icon:"mdi:function-variant",placement:"right",card:void 0},{icon:o(()=>[a(s,{provider:"iconify",name:"mdi:function-variant"})]),title:o(()=>[t[7]||(t[7]=e("strong",null,"Lambda Calculus",-1)),t[8]||(t[8]=n()),a(l,{label:"LambdaCalculus",total:1},{"item-0":o(()=>t[6]||(t[6]=[e("p",null,"A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.",-1)])),_:1})]),default:o(()=>[t[9]||(t[9]=e("p",null,[n("A mathematical model based on function application and composition. It is the foundation for the "),e("mark",null,"functional programming"),n(" paradigm.")],-1))]),_:1,__:[9]}),a(m,{time:"1945",icon:"mdi:cpu-64-bit",card:void 0},{icon:o(()=>[a(s,{provider:"iconify",name:"mdi:cpu-64-bit"})]),title:o(()=>[t[11]||(t[11]=e("strong",null,"von Neumann Architecture",-1)),t[12]||(t[12]=n()),a(l,{label:"vonNeumann",total:1},{"item-0":o(()=>t[10]||(t[10]=[e("p",null,"A model of computation which is the basis for most modern computer architectures, proposed by John von Neumann in 1945.",-1)])),_:1})]),default:o(()=>[t[13]||(t[13]=e("p",null,"A practical hardware model that unifies program instructions and data in memory. This is the basis for most modern computers and follows an imperative model.",-1))]),_:1,__:[13]})]),_:1}),t[64]||(t[64]=d('<h4 id="the-instruction-execution-cycle" tabindex="-1"><a class="header-anchor" href="#the-instruction-execution-cycle"><span>The Instruction Execution Cycle</span></a></h4><p>Modern machines based on the von Neumann architecture operate on a simple, continuous cycle.</p><div class="vp-steps"><ol><li><strong>Fetch</strong>: The CPU fetches the next instruction from memory.</li><li><strong>Decode</strong>: The CPU decodes the instruction to determine the operation and any operands.</li><li><strong>Execute</strong>: The CPU performs the operation.</li><li><strong>Store</strong>: If necessary, the result is stored back in a register or memory.</li></ol></div><hr><h3 id="dominant-programming-paradigms" tabindex="-1"><a class="header-anchor" href="#dominant-programming-paradigms"><span>Dominant Programming Paradigms</span></a></h3><p>Paradigms are different ways to create abstractions, allowing programmers to manage complexity and build robust, scalable code.</p>',6)),a(g,{accordion:"",index:0},{default:o(()=>[a(r,{expand:"",index:0},{title:o(()=>t[14]||(t[14]=[e("strong",null,"Imperative & Procedural",-1)])),default:o(()=>[t[15]||(t[15]=e("ul",null,[e("li",null,[e("strong",null,"Imperative"),n(" programs are a sequence of statements that change a program's state.")]),e("li",null,[e("strong",null,"Procedural"),n(" programming is a type of imperative programming that adds named subroutines (procedures or functions) which can be called from elsewhere in the program. Most modern languages support this.")])],-1))]),_:1,__:[15]}),a(r,{index:1},{title:o(()=>t[16]||(t[16]=[e("strong",null,"Object-Oriented (OO)",-1),n(" Built around the concept of ",-1),e("em",null,"objects",-1),n(", which bundle data (state) and the behaviors (methods) that operate on that data. It often models the world as a ",-1),e("mark",null,'"Kingdom of Nouns"',-1),n(".",-1)])),_:1}),a(r,{index:2},{title:o(()=>t[17]||(t[17]=[e("strong",null,"Declarative",-1),n(" Focuses on ",-1),e("mark",null,"what",-1),n(" a program should accomplish, rather than ",-1),e("mark",null,"how",-1),n(' it should be done. The underlying engine handles the "how". ',-1),e("mark",{class:"info"},"Examples",-1),n(": SQL, HTML, and Prolog.",-1)])),_:1}),a(r,{index:3},{title:o(()=>t[18]||(t[18]=[e("strong",null,"Functional (FP)",-1),n(" Built around composing pure, stateless functions. It supports ",-1),e("em",null,"higher-order functions",-1),n(" (functions that take or return other functions) and treats data as immutable. It can be thought of as a ",-1),e("mark",null,'"Kingdom of Verbs"',-1),n(".",-1)])),_:1})]),_:1}),t[65]||(t[65]=d('<details class="hint-container details"><summary>In-Depth Comparison: Functional vs. Object-Oriented</summary><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;"><strong>Functional</strong></th><th style="text-align:left;"><strong>Object-Oriented</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Unit of Composition</strong></td><td style="text-align:left;">Functions</td><td style="text-align:left;">Objects / Classes</td></tr><tr><td style="text-align:left;"><strong>Programming Style</strong></td><td style="text-align:left;">Declarative</td><td style="text-align:left;">Imperative</td></tr><tr><td style="text-align:left;"><strong>Control Flow</strong></td><td style="text-align:left;">Function calls, recursion, chaining</td><td style="text-align:left;">Loops, conditionals</td></tr><tr><td style="text-align:left;"><strong>Polymorphism</strong></td><td style="text-align:left;">Parametric (Generics)</td><td style="text-align:left;">Sub-Typing (Inheritance)</td></tr><tr><td style="text-align:left;"><strong>Data &amp; Behaviour</strong></td><td style="text-align:left;">Loosely coupled</td><td style="text-align:left;">Tightly coupled in objects</td></tr><tr><td style="text-align:left;"><strong>State Management</strong></td><td style="text-align:left;">Immutable state</td><td style="text-align:left;">Mutates state</td></tr><tr><td style="text-align:left;"><strong>Model of Computation</strong></td><td style="text-align:left;">Lambda Calculus</td><td style="text-align:left;">Imperative (von Neumann/Turing)</td></tr></tbody></table></details><hr>',2)),e("p",null,[t[29]||(t[29]=n("The study of programming languages involves understanding foundational concepts like ",-1)),t[30]||(t[30]=e("strong",null,"Syntax",-1)),t[31]||(t[31]=n()),a(l,{label:"Syntax",total:1},{"item-0":o(()=>t[19]||(t[19]=[e("p",null,"The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.",-1)])),_:1}),t[32]||(t[32]=n(", ",-1)),t[33]||(t[33]=e("strong",null,"Semantics",-1)),t[34]||(t[34]=n()),a(l,{label:"Semantics",total:1},{"item-0":o(()=>t[20]||(t[20]=[e("p",null,"The processes a computer follows when executing a program in a given language.",-1)])),_:1}),t[35]||(t[35]=n(", and models of computation such as the ",-1)),t[36]||(t[36]=e("strong",null,"Turing Machine",-1)),t[37]||(t[37]=n()),a(l,{label:"TuringMachine",total:1},{"item-0":o(()=>t[21]||(t[21]=[e("p",null,"A model of computation based on a hypothetical machine reading or writing instructions on a tape, which decides how to proceed based on the symbols it reads from the tape.",-1)])),_:1}),t[38]||(t[38]=n(", the ",-1)),t[39]||(t[39]=e("strong",null,"Lambda Calculus",-1)),t[40]||(t[40]=n()),a(l,{label:"LambdaCalculus",total:1},{"item-0":o(()=>t[22]||(t[22]=[e("p",null,"A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.",-1)])),_:1}),t[41]||(t[41]=n(", and the ",-1)),t[42]||(t[42]=e("strong",null,"von Neumann model",-1)),t[43]||(t[43]=n()),a(l,{label:"vonNeumann",total:1},{"item-0":o(()=>t[23]||(t[23]=[e("p",null,"A model of computation which is the basis for most modern computer architectures, proposed by John von Neumann in 1945.",-1)])),_:1}),t[44]||(t[44]=n(". From these models, several programming paradigms have emerged, including ",-1)),t[45]||(t[45]=e("strong",null,"Imperative",-1)),t[46]||(t[46]=n()),a(l,{label:"Imperative",total:1},{"item-0":o(()=>t[24]||(t[24]=[e("p",null,"A programming paradigm where programs are a sequence of statements that change a program’s state.",-1)])),_:1}),t[47]||(t[47]=n(", ",-1)),t[48]||(t[48]=e("strong",null,"Procedural",-1)),t[49]||(t[49]=n()),a(l,{label:"Procedural",total:1},{"item-0":o(()=>t[25]||(t[25]=[e("p",null,[n("A type of imperative programming that adds the concept of named "),e("em",null,"procedures"),n(" or subroutines that may be invoked from elsewhere in the program.")],-1)])),_:1}),t[50]||(t[50]=n(", ",-1)),t[51]||(t[51]=e("strong",null,"Object-oriented",-1)),t[52]||(t[52]=n()),a(l,{label:"Object-oriented",total:1},{"item-0":o(()=>t[26]||(t[26]=[e("p",null,[n("A paradigm built around the concept of "),e("em",null,"objects"),n(", where an object captures the set of data (state) and behaviors (methods) associated with entities in the system.")],-1)])),_:1}),t[53]||(t[53]=n(", ",-1)),t[54]||(t[54]=e("strong",null,"Declarative",-1)),t[55]||(t[55]=n()),a(l,{label:"Declarative",total:1},{"item-0":o(()=>t[27]||(t[27]=[e("p",null,[n("A paradigm where languages focus on declaring "),e("em",null,"what"),n(" a procedure or function should do rather than "),e("em",null,"how"),n(" it should do it.")],-1)])),_:1}),t[56]||(t[56]=n(", and ",-1)),t[57]||(t[57]=e("strong",null,"Functional",-1)),t[58]||(t[58]=n()),a(l,{label:"Functional",total:1},{"item-0":o(()=>t[28]||(t[28]=[e("p",null,[n("A paradigm built around the concept of composable functions, supporting "),e("em",null,"higher-order functions"),n(" and following the rules of the "),e("em",null,"Lambda Calculus"),n(".")],-1)])),_:1}),t[59]||(t[59]=n(" programming.",-1))])])}const T=f(y,[["render",v]]),P=JSON.parse('{"path":"/programming-paradigm/xuzxs1gn/","title":"Level of Abstraction","lang":"en-US","frontmatter":{"title":"Level of Abstraction","createTime":"2025/08/05 11:33:44","permalink":"/programming-paradigm/xuzxs1gn/"},"readingTime":{"minutes":10.66,"words":853},"git":{"createdTime":1754402412000,"updatedTime":1754402412000,"changelog":[{"hash":"7cf8ded3dddc2ababaf9819f8a5fc508a75a8b9f","time":1754402412000,"email":"yunfeng.long@yahoo.com","author":"WARREN Y.F. LONG","message":"feat: add introductory notes on Functional Programming and Levels of Abstraction"}]},"filePathRelative":"notes/programming-paradigm/func_program/2.loa.md","headers":[]}');export{T as comp,P as data};
