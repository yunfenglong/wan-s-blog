import{a as i,c as o,d as t,e as n,b as a,r,o as l}from"./app-C7AwxLk6.js";const c={};function d(h,e){const s=r("Mermaid");return l(),o("div",null,[e[0]||(e[0]=t("h2",{id:"bsd-socket-api-programming-in-c",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#bsd-socket-api-programming-in-c"},[t("span",null,"BSD Socket API Programming in C")])],-1)),e[1]||(e[1]=t("p",null,"The Berkeley (BSD) Socket API is the standard low-level programming interface for network-based Inter-Process Communication (IPC). It is available on nearly all modern operating systems.",-1)),e[2]||(e[2]=t("p",null,"The process of establishing and managing a connection follows a defined state machine. The diagram below illustrates the sequence of states for both the client (active connection) and the server (passive connection).",-1)),n(s,{code:"eJyFkEtqwzAQQPc+xSzthS7QRcGRRCtw1FKZbo1RhkbElV15UhLI4WMJQ0wSEi0kMZ83j2GMZeSowxdYYdhhh0cwvd0hjcB779GS6z0Yaglh3dqt8wi8c+gJ8nJK/mORRchPaIct1CKD6WxcmBurrxTgjRKVzONVAGOvp5kNQ3C/LlIAD2j3hJsTlLxW37KRpi5XlTLva6nr5lNqofRboj0qWNKjQGstDgnLLw1S5It/MSsuQoki3Gifawpl+IfWkt91vM1eoaNjwL89jjS9FqcZyTWuKjsDa+2B/g=="}),n(s,{code:"eJyNkM0KwjAMx+97ihy3Q1/Ag6Br0cKsww6vY9SgRd20jaLgw7vNgcMvzCEJ+fjlTxhjAVna4QDG6La4wyvoymyRPMRVWaIhW5WgqSCEWWE2tkTQ6M7oIEwL7+0Zo6ChrF1x2EDGA6htZV23mSzaQppLnoiwcREwNrz14A6PJ/RUR4M1bnWDdKS1XIpc6Gw0TqSezoTK8lQoLtXkwfs10T8AB2f3lmou4AXNiVr+c0/wsJdHndheqYVx680/grnU8VwpEX9W+95+oX9R27wtuANr34d8"}),e[3]||(e[3]=a(`<h2 id="socket-primitives" tabindex="-1"><a class="header-anchor" href="#socket-primitives"><span>Socket Primitives</span></a></h2><p>The core of the Socket API is a set of functions, or primitives, used to manage the connection lifecycle.</p><table><thead><tr><th style="text-align:left;">Primitive</th><th style="text-align:left;">Meaning</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>SOCKET</strong></td><td style="text-align:left;">Creates a new communication endpoint.</td></tr><tr><td style="text-align:left;"><strong>BIND</strong></td><td style="text-align:left;">Associates a local address and port with a socket.</td></tr><tr><td style="text-align:left;"><strong>LISTEN</strong></td><td style="text-align:left;">Announces willingness to accept connections (server-side).</td></tr><tr><td style="text-align:left;"><strong>ACCEPT</strong></td><td style="text-align:left;">Passively establishes an incoming connection (server-side).</td></tr><tr><td style="text-align:left;"><strong>CONNECT</strong></td><td style="text-align:left;">Actively attempts to establish a connection (client-side).</td></tr><tr><td style="text-align:left;"><strong>SEND</strong></td><td style="text-align:left;">Sends data over the connection.</td></tr><tr><td style="text-align:left;"><strong>RECEIVE</strong></td><td style="text-align:left;">Receives data from the connection.</td></tr><tr><td style="text-align:left;"><strong>CLOSE</strong></td><td style="text-align:left;">Releases the connection.</td></tr></tbody></table><h2 id="programming-with-the-socket-api" tabindex="-1"><a class="header-anchor" href="#programming-with-the-socket-api"><span>Programming with the Socket API</span></a></h2><p>Socket programming follows a <strong>client-server model</strong>, where a server process must be running and listening before a client can connect to it.</p><p>For C programming, the following header files are typically required:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">stdio.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">sys/types.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">sys/socket.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">netinet/in.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="server-side-programming-steps" tabindex="-1"><a class="header-anchor" href="#server-side-programming-steps"><span>Server-Side Programming Steps</span></a></h3><ol><li><strong><code>socket()</code></strong>: Create a new socket endpoint.</li><li><strong><code>bind()</code></strong>: Assign a specific IP address and port number to the socket so clients know where to find it.</li><li><strong><code>listen()</code></strong>: Place the socket in a listening state to monitor for incoming connection requests from clients.</li><li><strong><code>accept()</code></strong>: Accept an incoming connection from a client, which creates a new socket for the actual communication.</li></ol><h3 id="client-side-programming-steps" tabindex="-1"><a class="header-anchor" href="#client-side-programming-steps"><span>Client-Side Programming Steps</span></a></h3><ol><li><strong><code>socket()</code></strong>: Create a new socket endpoint.</li><li><strong><code>connect()</code></strong>: Use the server&#39;s IP address and port number to establish a connection to the listening server socket.</li><li><strong><code>write()</code> / <code>read()</code></strong>: Once the server accepts the connection, use standard system calls to send and receive data.</li><li><strong><code>close()</code></strong>: Shut down the connection when communication is finished.</li></ol><h2 id="key-socket-parameters" tabindex="-1"><a class="header-anchor" href="#key-socket-parameters"><span>Key Socket Parameters</span></a></h2><p>The <code>int socket(int domain, int type, int protocol)</code> function has two particularly important parameters:</p><ul><li><strong><code>domain</code></strong>: Specifies the communication protocol family. Key values include: <ul><li><strong><code>PF_LOCAL</code></strong> (or <code>PF_UNIX</code>): For IPC between processes on the <strong>same host</strong>.</li><li><strong><code>PF_INET</code></strong>: For communication over IPv4 networks.</li><li><strong><code>PF_INET6</code></strong>: For communication over IPv6 networks.</li></ul></li><li><strong><code>type</code></strong>: Defines the semantics of communication. The most common types are: <ul><li><strong><code>SOCK_STREAM</code></strong>: Provides a sequenced, reliable, two-way byte stream. This corresponds to <strong>TCP</strong>.</li><li><strong><code>SOCK_DGRAM</code></strong>: Provides a connectionless, unreliable datagram service. This corresponds to <strong>UDP</strong>.</li></ul></li></ul><h2 id="api-caveats-and-abstraction" tabindex="-1"><a class="header-anchor" href="#api-caveats-and-abstraction"><span>API Caveats and Abstraction</span></a></h2><ul><li><strong>Programmer Responsibility</strong>: While the API is straightforward, it requires the programmer to manually manage the connection state and handle all potential errors.</li><li><strong>Abstraction Level</strong>: The <code>socket()</code> call returns an integer <strong>file descriptor</strong>. This is a lower-level abstraction than the <code>FILE*</code> pointer used by standard C library functions like <code>fread()</code> and <code>fwrite()</code>. The standard <code>read()</code> and <code>write()</code> system calls operate directly on these file descriptors.</li></ul><h2 id="example-http-over-sockets" tabindex="-1"><a class="header-anchor" href="#example-http-over-sockets"><span>Example: HTTP over Sockets</span></a></h2><p>A common use case for sockets is the Hypertext Transfer Protocol (HTTP).</p><ol><li>A web browser (client) opens a <code>SOCK_STREAM</code> socket to a web server on its public port (typically port 80).</li><li>The client sends a plain-text HTTP request, such as <code>GET /index.html HTTP/1.1</code>.</li><li>The server processes the request, opens a connection back, and sends an HTTP response (e.g., <code>HTTP/1.1 200 OK</code>) followed by the requested data.</li><li>The socket connections are then closed.</li></ol><p>This simple, text-based protocol design is inherently verbose. The need to establish new connections for each object on a webpage contributes to latency, which has motivated the development of more efficient protocols like QUIC.</p><h2 id="remote-procedure-call" tabindex="-1"><a class="header-anchor" href="#remote-procedure-call"><span>Remote Procedure Call</span></a></h2><h3 id="what-is-a-remote-procedure-call-rpc" tabindex="-1"><a class="header-anchor" href="#what-is-a-remote-procedure-call-rpc"><span>What is a Remote Procedure Call (RPC)?</span></a></h3><p>A <strong>Remote Procedure Call (RPC)</strong> is a higher level of abstraction for network communication than raw sockets. Instead of simply sending and receiving streams of data, RPC allows a client process to execute a procedure (or function) on a remote server as if it were a local function call.</p><p>This is a <strong>structured API</strong> that confines communication to specific messages: procedure calls from the client and value returns from the server. The most widely used protocol for this is the <strong>Open Network Computing Remote Procedure Call (ONC RPC)</strong>.</p><hr><h3 id="how-rpc-works" tabindex="-1"><a class="header-anchor" href="#how-rpc-works"><span>How RPC Works</span></a></h3><p>The core idea of RPC is to make distributed programming look like conventional programming. This is achieved through the use of <strong>stubs</strong>.</p><ol><li><strong>Client-Side</strong>: When a client application calls a remote procedure, it actually calls a local function known as a <strong>client stub</strong>. This stub is responsible for packing the procedure&#39;s arguments into a message, a process called <strong>marshalling</strong>.</li><li><strong>Network Transfer</strong>: The client stub then sends this message over the network to the server. After sending the request, the client process typically <strong>blocks</strong>, waiting for a response.</li><li><strong>Server-Side</strong>: A corresponding <strong>server stub</strong> on the remote machine receives the message, unpacks the arguments (unmarshalling), and calls the actual procedure with those arguments.</li><li><strong>Response</strong>: After the procedure finishes, the server stub marshals the return values into a response message and sends it back to the client. The client stub unmarshals the response and returns the values to the client application, unblocking it.</li></ol><p>From the application developer&#39;s perspective, the network communication is completely hidden by the stubs.</p><hr><h3 id="the-rpc-development-process" tabindex="-1"><a class="header-anchor" href="#the-rpc-development-process"><span>The RPC Development Process</span></a></h3><p>RPC simplifies development by automating the creation of network communication code.</p><ul><li><strong>Interface Definition</strong>: First, the developer defines the remote procedures, their parameters, and their return types in an <strong>Interface Definition Language (IDL)</strong> file.</li><li><strong>Stub Generation</strong>: An <strong>RPC compiler</strong> processes this IDL file and automatically generates the source code for both the client stub and the server stub (sometimes called a skeleton).</li><li><strong>Compilation and Linking</strong>: <ul><li>The client stub is compiled and linked with the client application code.</li><li>The server stub is compiled and linked with the actual implementation of the remote procedures.</li></ul></li><li><strong>Execution</strong>: This process results in two separate executable binaries: the client program and the server program. The server must be installed and running before the client can make any remote calls to it.</li></ul><hr><h3 id="key-rpc-concepts" tabindex="-1"><a class="header-anchor" href="#key-rpc-concepts"><span>Key RPC Concepts</span></a></h3><ul><li><strong>Transparency</strong>: The goal is to make the remote call as transparent as possible to the developer, though issues like network latency and failures can break this illusion.</li><li><strong>Endianness and XDR</strong>: Different computers may store data in different byte orders (&quot;endianness&quot;). To solve this, ONC RPC uses the <strong>eXternal Data Representation (XDR)</strong> protocol, which standardizes the format of data before it&#39;s sent over the network, ensuring it can be correctly interpreted by any machine architecture.</li><li><strong>Competing Standards</strong>: While ONC RPC (popularized by Sun Microsystems for its Network File System) is widely used, a competing standard was DCE/RPC, which later influenced Microsoft technologies like DCOM and .NET Remoting.</li></ul>`,36))])}const g=i(c,[["render",d]]),m=JSON.parse('{"path":"/fit3143/jz3xkjx7/","title":"BSD Socket","lang":"en-US","frontmatter":{"title":"BSD Socket","createTime":"2025/08/02 21:19:49","permalink":"/fit3143/jz3xkjx7/"},"readingTime":{"minutes":14.96,"words":1197},"git":{"createdTime":1754146040000,"updatedTime":1754146040000,"changelog":[{"hash":"38fa9a6d0a743a0a4735de8761312f7220e0f7dc","time":1754146040000,"email":"yunfeng.long@yahoo.com","author":"wanfunglung","message":"feat: add new notes on parallel architectures, applications, and IPC mechanisms"}]},"filePathRelative":"notes/fit3143/ipc/4.bsd.md","headers":[]}');export{g as comp,m as data};
