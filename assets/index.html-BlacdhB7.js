import{a as o,c as l,b as s,d as t,f as n,e as i,w as r,r as p,o as d}from"./app-C7AwxLk6.js";const g={},u={start:"5"};function m(f,e){const a=p("VPLink");return d(),l("div",null,[e[14]||(e[14]=s('<div class="hint-container note"><p class="hint-container-title">Note</p><p>This guide provides a complete exploration of TypeScript&#39;s language concepts, from fundamentals to advanced topics. This covers type annotations, interfaces, generics, union types, optional properties, and how TypeScript enhances JavaScript with static type checking while maintaining full compatibility.</p></div><h2 id="course-structure" tabindex="-1"><a class="header-anchor" href="#course-structure"><span><strong>Course Structure</strong></span></a></h2><h3 id="core-fundamentals" tabindex="-1"><a class="header-anchor" href="#core-fundamentals"><span><strong>Core Fundamentals</strong></span></a></h3>',3)),t("ol",null,[t("li",null,[t("strong",null,[i(a,{href:"./1.basic.md"},{default:r(()=>e[0]||(e[0]=[n("Basic Concepts",-1)])),_:1,__:[0]})]),e[1]||(e[1]=n(" - Type annotations, primitive types, and type inference",-1))]),t("li",null,[t("strong",null,[i(a,{href:"./2.union-types.md"},{default:r(()=>e[2]||(e[2]=[n("Union Types",-1)])),_:1,__:[2]})]),e[3]||(e[3]=n(" - Working with multiple types and type disambiguation",-1))]),t("li",null,[t("strong",null,[i(a,{href:"./3.interfaces.md"},{default:r(()=>e[4]||(e[4]=[n("Interfaces",-1)])),_:1,__:[4]})]),e[5]||(e[5]=n(" - Object shapes and type definitions",-1))]),t("li",null,[t("strong",null,[i(a,{href:"./4.generics.md"},{default:r(()=>e[6]||(e[6]=[n("Generic Types",-1)])),_:1,__:[6]})]),e[7]||(e[7]=n(" - Creating reusable type-safe components",-1))])]),e[15]||(e[15]=t("h3",{id:"advanced-language-concepts",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#advanced-language-concepts"},[t("span",null,[t("strong",null,"Advanced Language Concepts")])])],-1)),t("ol",u,[t("li",null,[t("strong",null,[i(a,{href:"./5.optional-properties.md"},{default:r(()=>e[8]||(e[8]=[n("Optional Properties",-1)])),_:1,__:[8]})]),e[9]||(e[9]=n(" - Working with optional and readonly properties",-1))]),t("li",null,[t("strong",null,[i(a,{href:"./6.type-safety.md"},{default:r(()=>e[10]||(e[10]=[n("Type Safety",-1)])),_:1,__:[10]})]),e[11]||(e[11]=n(" - Ensuring immutability and compile-time checking",-1))]),t("li",null,[t("strong",null,[i(a,{href:"./7.practical-applications.md"},{default:r(()=>e[12]||(e[12]=[n("Practical Applications",-1)])),_:1,__:[12]})]),e[13]||(e[13]=n(" - Real-world TypeScript patterns and best practices",-1))])]),e[16]||(e[16]=s('<h2 id="learning-path" tabindex="-1"><a class="header-anchor" href="#learning-path"><span><strong>Learning Path</strong></span></a></h2><p>This guide is structured to build knowledge progressively:</p><ul><li><strong>Start with Core Fundamentals</strong> (Sections 1-4) to understand TypeScript&#39;s basic building blocks</li><li><strong>Move to Advanced Concepts</strong> (Sections 5-7) to master sophisticated typing patterns</li><li><strong>Apply knowledge through practical examples</strong> demonstrating TypeScript&#39;s power in real-world scenarios</li></ul>',3))])}const y=o(g,[["render",m]]),h=JSON.parse('{"path":"/programming-paradigm/ts/","title":"Comprehensive TypeScript Language Guide","lang":"en-US","frontmatter":{"title":"Comprehensive TypeScript Language Guide","createTime":"2025/08/05 12:00:00","permalink":"/programming-paradigm/ts/"},"readingTime":{"minutes":2.38,"words":190},"git":{"createdTime":1754751767000,"updatedTime":1754751767000,"changelog":[{"hash":"94b03af6a35b8b0c0014e0b69430db6dbf87df22","time":1754751767000,"email":"yunfeng.long@yahoo.com","author":"WARREN Y.F. LONG","message":"feat: readme for ts"}]},"filePathRelative":"notes/programming-paradigm/ts/README.md","headers":[]}');export{y as comp,h as data};
