---
title: Graph Basic
createTime: 2025/06/06 11:21:13
permalink: /fit2004/fa8bt1no/
---

### Representations and Storage of Graphs

#### Representation Strategy - Adjacency Matrix

:::note Adjacency Matrix
One way to represent a graph is using an **adjacency matrix**. The adjacency matrix of a graph $G = (V, E)$ is a matrix $A$ of size $|V| × |V|$.

**Space requirement:** $O(|V|^2)$
:::

When the edges are unweighted, the entries of the adjacency matrix are
defined by

$$
a_{i, \ j} = \begin{cases}      1, & \text{if there is an edge(i, j)}\\
      0, & \text{otherwise}
    \end{cases}       
$$

In a weighted graph, the adjacency matrix stores the weights of the edges, such that

$$
a_{i, \ j} = \begin{cases}      w(i, \ j), & \text{if there is an edge(i, j)}\\
      0 \ or\  \infty, & \text{otherwise}
    \end{cases}       
$$

#### Representation Strategy – Adjacency List

:::tip Adjacency List Advantages
**When to use:**
- **Dense graphs:** Adjacency matrices use fixed $O(|V|^2)$ space
- **Sparse graphs:** Adjacency lists are much more efficient

**Key benefits:**
- Only uses memory for edges that ==actually exist==
- **Space complexity:** $O(|V| + |E|)$ 
- **Huge improvement** for sparse graphs over adjacency matrices
:::

#### Representation Strategy – Edge List

:::info Edge List Characteristics
**Space:** $O(|E|)$ - most space-efficient

**Limitations:**
- Cannot check adjacency quickly
- Cannot iterate over adjacent vertices efficiently

**Primary use:** ==Kruskal’s MST algorithm== - needs to sort all edges by weight
:::

### Graph Traversal

#### Depth-First Search

:::important DFS Strategy
A **depth-first traversal** searches by following a path as ==deep as possible== from the starting vertex before backtracking.

**Process:**
1. Go as deep as possible until reaching a dead end
2. Backtrack and continue searching unexplored vertices
3. Maintain visited flags to avoid infinite loops
:::

```python
def dfs_iterative(graph, start_node):
  """
  Performs an iterative Depth First Search on a graph.

  Args:
    graph: A dictionary representing the adjacency list of the graph.
    start_node: The node to start the search from.

  Returns:
    A list of nodes in DFS traversal order.
  """
  visited = set()
  stack = [start_node]
  traversal_order = []

  while stack:
    vertex = stack.pop()
    if vertex not in visited:
      visited.add(vertex)
      traversal_order.append(vertex)
      # Add neighbors to the top of the stack
      for neighbor in reversed(graph[vertex]):
          if neighbor not in visited:
              stack.append(neighbor)
  return traversal_order
```

```python
def dfs_recursive(graph, node, visited=None, traversal_order=None):
  """
  Performs a recursive Depth First Search on a graph.

  Args:
    graph: A dictionary representing the adjacency list of the graph.
    node: The current node to visit.
    visited: A set to keep track of visited nodes (used in recursion).
    traversal_order: A list to store the traversal order.

  Returns:
    A list of nodes in DFS traversal order.
  """
  if visited is None:
    visited = set()
  if traversal_order is None:
      traversal_order = []

  visited.add(node)
  traversal_order.append(node)

  for neighbor in graph[node]:
    if neighbor not in visited:
      dfs_recursive(graph, neighbor, visited, traversal_order)
  return traversal_order
```

#### Finding Connected Components

:::tip Connected Components Algorithm
**Key insight:** A single DFS call visits ==exactly one connected component==

**Strategy:**
1. Run DFS from each unvisited vertex
2. Each DFS call discovers one complete component
3. Repeat until all vertices are visited

**Time Complexity:** $O(|V| + |E|)$
:::

```python
def DFS(u, comp_num, graph, component):
    """
    // One DFS will visit a single connected component
    A recursive Depth-First Search that marks all vertices in a
    single component with the same component number.

    Args:
        u (int): The current vertex to visit.
        comp_num (int): The identifier for the current connected component.
        graph (list): The graph's adjacency list.
        component (list): The list mapping vertices to component numbers.
    """
    # component[u] = comp_num
    component[u] = comp_num

    # for each vertex v adjacent to u do
    for v in graph[u]:
        # if component[v] = null then
        # We use 0 to represent 'null' (unvisited).
        if component[v] == 0:
            DFS(v, comp_num, graph, component)

def Connected_components(graph, n):
    """
    // Driver function that finds each connected component
    Implements Algorithm 26 to find and label connected components.

    Args:
        graph (list): The graph's adjacency list representation.
        n (int): The total number of vertices.

    Returns:
        tuple: A tuple containing:
            - num_components (int): The total count of components.
            - component (list): A list where component[i] is the
                                component ID for vertex i.
    """
    # component[1..n] = null
    # We create a list of size n+1 and initialize with 0s ('null').
    component = [0] * (n + 1)
    
    # num_components = 0
    num_components = 0

    # for each vertex u = 1 to n do
    for u in range(1, n + 1):
        # if component[u] = null then
        if component[u] == 0:
            num_components = num_components + 1
            DFS(u, num_components, graph, component)
            
    # return num_components, component[1..n]
    return num_components, component
```

#### Cycle Finding

Recall that a cycle is a path consisting of a non-empty sequence of distinct, adjacent edges that begins and ends at the same vertex. Consider an undirected, unweighted graph G = (V , E ). Suppose without loss of generality that G is connected. Performing a depth-first search on G will form a depth-first search tree T that covers every vertex $v ∈V$ . If at any point the search finds an edge that leads to a vertex that it has already visited, then this edge connects two vertices u, v that are already connected in T and hence forms part of a cycle. We must be careful not to accidentally interpret the edge we just came from as a cycle though (since this “cycle” would use the same edge twice). To account for this, we’ll have our DFS keep an extra parameter p , the vertex that we just came from, so that we know not to interpret (u, p ) as part of a cycle.

```python
def DFS(u, p, graph, visited):
    """
    // Returns True if a cycle was detected
    A recursive Depth-First Search that looks for a back edge.

    Args:
        u (int): The current vertex being visited.
        p (int): The parent vertex of u in the DFS tree.
        graph (list): The graph's adjacency list.
        visited (list): The list tracking visited vertices.

    Returns:
        bool: True if a cycle is found, otherwise False.
    """
    # visited[u] = true
    visited[u] = True

    # for each vertex v adjacent to u do
    for v in graph[u]:
        # The pseudocode's logic is implemented in these three conditions.

        # Condition 1: If neighbor v is the parent, ignore it and continue.
        if v == p:
            continue

        # Condition 2: If neighbor v is visited and not the parent, we found a cycle.
        # This corresponds to line 13: if visited[v] and v != p then
        if visited[v]:
            return True  # A back edge is found, indicating a cycle.

        # Condition 3: Recurse on unvisited neighbor. If the recursive call finds a cycle, propagate the result.
        # This corresponds to line 15: else if v != p and DFS(v, u) = true then
        # The 'if not visited[v]' check is implicitly handled by the logic flow.
        if DFS(v, u, graph, visited):
            return True

    # If the loop completes without finding a cycle from this path, return false.
    return False

def has_cycle(graph, n):
    """
    // Driver function that calls DFS to look for a cycle
    Checks if an undirected graph contains a cycle.

    Args:
        graph (list): The graph's adjacency list representation.
        n (int): The total number of vertices.

    Returns:
        bool: True if the graph contains a cycle, otherwise False.
    """
    # visited[1..n] = false
    # We create a list of size n+1, initialized to False.
    visited = [False] * (n + 1)

    # for each vertex u = 1 to n do
    for u in range(1, n + 1):
        # if not visited[u] then
        if not visited[u]:
            # if DFS(u, null) = true then
            # We use 0 as the 'null' parent for a starting node.
            if DFS(u, 0, graph, visited):
                return True

    # If the loop finishes, no cycles were found in any component.
    return False
```

#### Breadth-First Search

:::note BFS vs DFS
**Breadth-first search** traverses a graph one vertex at a time, just like DFS.

**Key difference:** The ==order== in which vertices are visited
- **BFS:** Explores all neighbors at current depth before going deeper
- **DFS:** Goes as deep as possible before backtracking
:::

```python
from collections import deque

def bfs(graph, start_node):
  """
  Performs a Breadth First Search on a graph.

  Args:
    graph: A dictionary representing the adjacency list of the graph.
    start_node: The node to start the search from.

  Returns:
    A list of nodes in BFS traversal order.
  """
  visited = set()
  queue = deque([start_node])
  traversal_order = []

  visited.add(start_node)

  while queue:
    vertex = queue.popleft() # Dequeue the first node
    traversal_order.append(vertex)

    for neighbor in graph[vertex]:
      if neighbor not in visited:
        visited.add(neighbor)
        queue.append(neighbor) # Enqueue the neighbor
  return traversal_order
```

#### Shortest Path

```python
from collections import deque

def BFS_shortest_path(graph, n, s):
    """
    Implements Algorithm 29 using the efficient collections.deque for the queue.
    """
    infinity = float('inf')
    dist = [infinity] * (n + 1)
    pred = [0] * (n + 1)

    # Use deque for an efficient O(1) queue implementation
    queue = deque([s])  # Initialize the deque with the source vertex
    
    dist[s] = 0

    while queue:  # A deque is "truthy" when it has items, "falsy" when empty
        u = queue.popleft() # Use popleft() for an efficient O(1) dequeue

        for v in graph[u]:
            if dist[v] == infinity:
                dist[v] = dist[u] + 1
                pred[v] = u
                queue.append(v) # append() is the standard enqueue operation

    return dist, pred
```

### Directed Acyclic Graph (DAG)

:::important DAG Definition
**For an edge** $\langle A, B \rangle$:
- $A$ is a ==prerequisite== for $B$
- $A$ is an ==ancestor== of $B$ 
- $A$ is ==ordered before== $B$
:::

:::note Topological Sort Properties
A **topological sort** is a permutation of vertices in a DAG where:
- Vertex $U$ appears before vertex $V$ if edge $\langle U, V \rangle$ exists
- If no edge $\langle V, W \rangle$ exists, then $V$ and $W$ have the same order
:::

:::tip Basic Algorithm Steps
1. **Start** with vertices without incoming edges
2. **Delete** all outgoing edges from the vertex
3. **Add** new vertices without incoming edges  
4. **Repeat** until complete!
:::

#### Kahn's Algorithm for Topological Sorting

:::important Kahn's Algorithm
The most well-known algorithm for topological sorting. It maintains a ==queue of vertices== that are ready to be completed and inserts them one by one into the topological ordering.
:::

```python
from collections import deque

def topological_sort(graph):
    """
    Performs a topological sort on a Directed Acyclic Graph (DAG)
    using Kahn's algorithm (Algorithm 31).

    Args:
        graph (dict): The graph represented as an adjacency list.
                      Example: {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}

    Returns:
        list: A list of vertices in topologically sorted order,
              or an empty list if the graph has a cycle.
    """
    # Step 1: Compute in-degrees of all vertices
    in_degree = {u: 0 for u in graph}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1

    # Step 3: Initialize the queue with all vertices having an in-degree of 0
    # ready = queue of all vertices with no incoming edges
    ready_queue = deque([u for u in graph if in_degree[u] == 0])

    # order = empty array
    order = []

    # Step 4: while ready is not empty do
    while ready_queue:
        # u = ready.pop()
        u = ready_queue.popleft()
        
        # order.append(u)
        order.append(u)

        # Step 7: for each edge (u, v) adjacent to u do
        for v in graph[u]:
            # Step 8: Remove (u, v) from G (by decrementing in-degree)
            in_degree[v] -= 1
            
            # Step 9: if v has no remaining incoming edges then
            if in_degree[v] == 0:
                # ready.push(v)
                ready_queue.append(v)

    # Final Step: Check if the graph has a cycle
    if len(order) == len(graph):
        return order
    else:
        # This indicates a cycle was present in the graph.
        print("Error: Graph contains a cycle, topological sort not possible.")
        return []
```

:::tip Complexity Analysis
**Time & Space:** $O(|V| + |E|)$

**Why:** Each vertex is visited once and every edge is removed once
:::

#### Topological Sorting Using DFS

```python
def topological_sort(graph, n):
    """
    A literal translation of the provided pseudocode (Algorithm 32)
    for topological sorting using DFS.

    This implementation strictly uses lists as arrays and follows the
    append-then-reverse logic.

    Args:
        graph (list): The graph as a list-of-lists adjacency list.
                      Vertices must be integers from 1 to n.
        n (int): The number of vertices in the graph.

    Returns:
        list: A list of vertices in topologically sorted order.
    """
    # order = empty array
    order = []
    # visited[1..n] = false
    visited = [False] * (n + 1) # Use list as a boolean array, ignore index 0

    # function DFS(u)
    def DFS(u):
        # visited[u] = true
        visited[u] = True
        
        # for each vertex v adjacent to u do
        for v in graph[u]:
            # if not visited[v] then
            if not visited[v]:
                # DFS(v)
                DFS(v)
        
        # order.append(u) // Add to order after visiting descendants
        order.append(u)

    # for each vertex v = 1 to n do
    for v in range(1, n + 1):
        # if not visited[v] then
        if not visited[v]:
            # DFS(v)
            DFS(v)

    # return reverse(order)
    # The [::-1] slice is an efficient way to reverse a list in Python
    return order[::-1]
```

:::tip DFS Topological Sort Complexity
**Time Complexity:** $O(|V| + |E|)$

**Process:** Perform DFS and append $|V|$ items to array, then reverse
:::

### The Union-Find Disjoint-Set Data Structure

:::important Union-Find Operations

**FIND(u):** Determine which set element $u$ is contained in  
- Returns the ==representative== of the set containing $u$

**UNION(u, v):** Join the sets containing $u$ and $v$ into a single set  
- May change the representatives of the sets

:::
