---
title: Level of Abstraction
createTime: 2025/08/05 11:33:44
permalink: /programming-paradigm/xuzxs1gn/
---

This document explores the evolution of programming languages as tools that create layers of abstraction over computer hardware. The goal is to move from low-level machine operations to high-level, human-understandable programs. Key concepts include the difference between ==syntax== and ==semantics==, various ==models of computation==, and the ==dominant programming paradigms== that shape how we solve problems.

---

### Syntax vs. Semantics

A foundational concept in programming languages is the distinction between *what a program looks like* and *what a program means*.

:::: field-group
::: field name="Syntax" type="string"
The symbols, grammar, and structural rules that define a correctly written program. It's about the ==form==. For example, using `{}` versus indentation for code blocks is a syntactic choice.
:::

::: field name="Semantics" type="string"
The meaning of a program and the computational processes it follows when executed. It's about the ==function and meaning==. For example, two functions in different languages can be syntactically different but semantically identical if they compute the same result.
:::
::::

---

### Models of Computation

Different programming paradigms are built upon different conceptual models of how a computer works.

::: timeline
- **Turing Machines** [+TuringMachine]
  time=1930s icon=mdi:tape-drive
  
  A conceptual model using a tape-reading machine. It forms the basis of the ==imperative== paradigm of sequential instruction execution.

- **Lambda Calculus** [+LambdaCalculus]
  time=1930s icon=mdi:function-variant placement=right
  
  A mathematical model based on function application and composition. It is the foundation for the ==functional programming== paradigm.

- **von Neumann Architecture** [+vonNeumann]
  time=1945 icon=mdi:cpu-64-bit
  
  A practical hardware model that unifies program instructions and data in memory. This is the basis for most modern computers and follows an imperative model.
:::

#### The Instruction Execution Cycle
Modern machines based on the von Neumann architecture operate on a simple, continuous cycle.
:::: steps
1. **Fetch**: The CPU fetches the next instruction from memory.
2. **Decode**: The CPU decodes the instruction to determine the operation and any operands.
3. **Execute**: The CPU performs the operation.
4. **Store**: If necessary, the result is stored back in a register or memory.
::::

---

### Dominant Programming Paradigms

Paradigms are different ways to create abstractions, allowing programmers to manage complexity and build robust, scalable code.

::: collapse accordion
- :+ **Imperative & Procedural**
  - **Imperative** programs are a sequence of statements that change a program's state.
  - **Procedural** programming is a type of imperative programming that adds named subroutines (procedures or functions) which can be called from elsewhere in the program. Most modern languages support this.

- **Object-Oriented (OO)**
  Built around the concept of *objects*, which bundle data (state) and the behaviors (methods) that operate on that data. It often models the world as a =="Kingdom of Nouns"==.

- **Declarative**
  Focuses on ==what== a program should accomplish, rather than ==how== it should be done. The underlying engine handles the "how".
  ==Examples=={.info}: SQL, HTML, and Prolog.

- **Functional (FP)**
  Built around composing pure, stateless functions. It supports *higher-order functions* (functions that take or return other functions) and treats data as immutable. It can be thought of as a =="Kingdom of Verbs"==.
:::

::: details In-Depth Comparison: Functional vs. Object-Oriented
| | **Functional** | **Object-Oriented** |
| :--- | :--- | :--- |
| **Unit of Composition** | Functions | Objects / Classes |
| **Programming Style** | Declarative | Imperative |
| **Control Flow** | Function calls, recursion, chaining | Loops, conditionals |
| **Polymorphism** | Parametric (Generics) | Sub-Typing (Inheritance) |
| **Data & Behaviour** | Loosely coupled | Tightly coupled in objects |
| **State Management** | Immutable state | Mutates state |
| **Model of Computation**| Lambda Calculus | Imperative (von Neumann/Turing) |
:::

---

The study of programming languages involves understanding foundational concepts like **Syntax** [+Syntax], **Semantics** [+Semantics], and models of computation such as the **Turing Machine** [+TuringMachine], the **Lambda Calculus** [+LambdaCalculus], and the **von Neumann model** [+vonNeumann]. From these models, several programming paradigms have emerged, including **Imperative** [+Imperative], **Procedural** [+Procedural], **Object-oriented** [+Object-oriented], **Declarative** [+Declarative], and **Functional** [+Functional] programming.

[+Syntax]:
  The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.

[+Semantics]:
  The processes a computer follows when executing a program in a given language.

[+TuringMachine]:
  A model of computation based on a hypothetical machine reading or writing instructions on a tape, which decides how to proceed based on the symbols it reads from the tape.

[+LambdaCalculus]:
  A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.

[+vonNeumann]:
  A model of computation which is the basis for most modern computer architectures, proposed by John von Neumann in 1945.

[+Imperative]:
  A programming paradigm where programs are a sequence of statements that change a programâ€™s state.

[+Procedural]:
  A type of imperative programming that adds the concept of named *procedures* or subroutines that may be invoked from elsewhere in the program.

[+Object-oriented]:
  A paradigm built around the concept of *objects*, where an object captures the set of data (state) and behaviors (methods) associated with entities in the system.

[+Declarative]:
  A paradigm where languages focus on declaring *what* a procedure or function should do rather than *how* it should do it.

[+Functional]:
  A paradigm built around the concept of composable functions, supporting *higher-order functions* and following the rules of the *Lambda Calculus*.