---
title: Introduction to JavaScript
createTime: 2025/08/05 11:45:58
permalink: /programming-paradigm/pxxnb71r/
---

::: note
JavaScript was created by Brendan Eich at Netscape in 1995. Though initially rushed, it survived to become a cornerstone of the modern web, maturing with the ECMAScript 6 (ES6) standard into an elegant, multi-paradigm language. This summary covers its fundamental concepts, from variables and scope to its powerful implementation of functions and classes.
:::

### Fundamental Concepts

JavaScript's core is built on a few essential concepts that govern how code is written and executed.

:::: card-grid
::: card title="Variables: `let` vs. `const`" icon="mdi:variable-box"
Variables are declared using `let` for **mutable** [+MutableVariable] (changeable) values and `const` for **immutable** [+ImmutableVariable] variables, whose values cannot be reassigned after their initial declaration. It is recommended to use `let` and `const` over the older `var` keyword.
:::

::: card title="Expressions vs. Statements" icon="mdi:code-braces"
An **expression** is any code that evaluates to a value (e.g., `1 + 1` evaluates to `2`). A **statement** performs an action and evaluates to `undefined`, such as a variable declaration or a code block defined with `{}`. Statements must have a **side effect** [+SideEffects] to be useful.
:::

::: card title="Types and Scope" icon="mdi:crosshairs-question"
JavaScript has primitive types like `number`, `string`, and `boolean`. It is **loosely typed**, meaning a variable's type can change during execution. A variable's **scope** is the region where it is visible, which can be limited by declaring it inside a code block `{...}`.
:::
::::

---

### The Power of Functions in JavaScript

Functions in JavaScript are first-class objects, leading to a progression of powerful concepts and patterns.

::: timeline
- **Basic Declaration & Purity**
  time=Step 1 icon=mdi:function
  
  Functions are declared with the `function` keyword and can use control flow like `if-else`, `while`, and `for`. Recursive functions written in a declarative style can be **pure** [+PureFunction], exhibiting **referential transparency** [+ReferentialTransparency] by avoiding side effects.

- **First-Class Citizens**
  time=Step 2 icon=mdi:hand-extended-outline placement=right
  
  Functions are objects, meaning they can be bound to variables and passed around just like any other value.

- **Anonymous & Arrow Functions**
  time=Step 3 icon=mdi:lambda
  
  Functions can be defined without a name (**anonymous functions** [+AnonymousFunction]). ES6 introduced compact **arrow syntax** (`=>`), which is ideal for passing functions as parameters to **higher-order functions** [+HigherOrderFunction] like `array.map()`.

- **Closures & Currying**
  time=Step 4 icon=mdi:lock-outline placement=right
  
  A **closure** [+Closure] is a function that captures variables from its enclosing scope, allowing those variables to persist. This enables patterns like **currying** [+Currying], where a function taking multiple arguments is transformed into a sequence of functions that each take one argument.
:::

---

### Working with Data Structures

JavaScript provides flexible ways to work with collections of data using arrays and objects.

::: collapse accordion
- :+ **Objects & Classes**
  - In JavaScript, objects are essentially property bags indexed by a hashtable. When an object is declared with `const`, the reference is immutable, but the object's properties remain mutable (*weakly immutable* [+WeaklyImmutable]). ES6 introduced a `class` syntax that is more familiar to Java or Python programmers, supporting constructors, methods, getters, and single inheritance.

- **Arrays & Methods**
  - JavaScript arrays have a simple literal syntax (`[1, 2, 3]`) and come with powerful, pure methods for data transformation.
  ==Key Methods=={.info}:
    * `map(f)`: Applies function `f` to each element, returning a new array.
    * `filter(f)`: Returns a new array containing only elements for which predicate `f` returns true.
    * `reduce(f, initial)`: Applies function `f` to combine all elements into a single aggregated value.

- **Polymorphism & Dependency Injection**
  - JavaScript supports *subtyping polymorphism* through classes and inheritance. It also allows for informal polymorphism known as “Duck Typing”. This can be contrasted with a more functional approach, **dependency injection**, where behavior is customized by passing functions into an object's constructor. Many modern languages also support **parametric polymorphism** [+ParametricPolymorphism] for creating generic, type-safe code.
:::

[+MutableVariable]:
  A variable declared with `let` that can be reassigned to different values.

[+ImmutableVariable]:
  A variable declared with `const` whose value cannot be reassigned.

[+SideEffects]:
  Any state change that occurs outside of a function's local environment or any observable interaction with the outside world, such as modifying a global variable, writing to a file, or printing to a console.

[+PureFunction]:
  A function that always produces the same output for the same input and has no side effects.

[+ReferentialTransparency]:
  An expression that can be replaced with its value without changing the program's behaviour, indicating no side effects and consistent results.

[+AnonymousFunction]:
  A function defined without a name, often used as an argument to other functions. Also known as a lambda function.

[+HigherOrderFunction]:
  A function that takes other functions as arguments or returns a function as its result.

[+Closure]:
  A function and the set of variables it accesses from its enclosing scope.

[+Currying]:
  The process of transforming a function that takes multiple arguments into a sequence of functions that each take a single argument.

[+WeaklyImmutable]:
  A property of `const`-declared objects in JavaScript, where the variable reference is immutable, but the object's properties can still be changed.

[+ParametricPolymorphism]:
  A type of polymorphism where functions or data types can be written generically so that they can handle values uniformly without depending on their type.