---
title: Objects and Prototypal Inheritance
createTime: 2025/08/05 12:13:04
permalink: /programming-paradigm/43pnhegz/
---
This section uncovers JavaScript's unique object model, from property descriptors to the prototype chain that underpins the `class` syntax.


- **Object Property Descriptors**
Every property on an object is defined by more than just its value. It has a "property descriptor" with internal attributes:

* `value`: The value of the property.
* `writable`: If `true`, the value can be changed.
* `enumerable`: If `true`, the property will appear in `for...in` loops and `Object.keys()`.
* `configurable`: If `true`, the property can be deleted, and its attributes (except `value` and `writable` if `writable` is `false`) can be changed.

You can view and modify these with `Object.getOwnPropertyDescriptor()` and `Object.defineProperty()`. This allows for fine-grained control over object behavior.

```javascript
const obj = {};
Object.defineProperty(obj, 'readOnly', {
    value: 42,
    writable: false,
    enumerable: true,
    configurable: false
});
// obj.readOnly = 100; // Fails silently (or throws in strict mode)
```

- **The Prototype Chain Explained**
Inheritance in JavaScript works via prototypes.

:::: field-group
::: field name="`prototype` Property"
Every *function* has a special `prototype` property. This is an object that will become the prototype for all instances created by that function when used as a constructor with `new`.
:::

::: field name="`[[Prototype]]` (or `__proto__`)"
Every *object instance* has a hidden `[[Prototype]]` link (often accessible via `__proto__`) that points to its prototype object.
:::
::::

When you access `instance.someMethod()`, the engine first looks for `someMethod` on `instance`. If not found, it follows the `[[Prototype]]` link and looks on `instance`'s prototype. This continues up the chain until the method is found or the end of the chain (`Object.prototype`, which has a `null` prototype) is reached.

**`Object.create()`**:
This is a direct way to create a new object with a specified prototype, bypassing the need for a constructor function. `const child = Object.create(parent);`

- **ES6 Classes: Syntactic Sugar and Advanced Features**
The `class` syntax provides a cleaner way to work with prototypes.

**`extends` and `super()`**:

* `extends` sets up the prototype chain. `class Child extends Parent {}` links `Child.prototype` to `Parent.prototype`.
* `super()` must be called in the child class's `constructor` *before* using `this`. It calls the parent constructor to initialize the parent part of the object.
* `super.method()` can be used to call a method from the parent class.

**Private Fields (`#`)**:
Modern JavaScript allows for truly private class fields using a `#` prefix. These fields are inaccessible from outside the class instance.

```javascript
class Counter {
    #count = 0; // Truly private field

    increment() {
    this.#count++;
    }

    getValue() {
    return this.#count;
    }
}

const c = new Counter();
// console.log(c.#count); // SyntaxError: Private field must be declared in an enclosing class
```

