---
title: Advanced Type System and Coercion Rules
createTime: 2025/08/05 13:25:00
permalink: /programming-paradigm/advanced-types/
---

This section explores JavaScript's type system in depth, covering coercion rules, type checking, and advanced type-related concepts.

## **JavaScript Type System Overview**

JavaScript has a dynamic type system with 7 primitive types and 1 object type:

### **Primitive Types**
- `Number`: 64-bit floating point values
- `String`: UTF-16 encoded text
- `Boolean`: `true` or `false`
- `Undefined`: Uninitialized variables
- `Null`: Intentional absence of value
- `Symbol`: Unique identifiers
- `BigInt`: Arbitrary precision integers

### **Reference Type**
- `Object`: Everything else (arrays, functions, dates, etc.)

```javascript
// Type checking with typeof
console.log(typeof 42);           // "number"
console.log(typeof 'hello');      // "string"
console.log(typeof true);         // "boolean"
console.log(typeof undefined);    // "undefined"
console.log(typeof null);         // "object" (historical bug)
console.log(typeof Symbol('id')); // "symbol"
console.log(typeof 42n);          // "bigint"
console.log(typeof {});           // "object"
console.log(typeof []);           // "object"
console.log(typeof function(){}); // "function"
```

## **Type Coercion Rules**

### **Abstract Operations**

JavaScript uses several abstract operations for type conversion:

#### **ToPrimitive**

Converts an object to a primitive value:

```javascript
// ToPrimitive algorithm
function toPrimitive(input, preferredType) {
    if (input === null || typeof input !== 'object') {
        return input;
    }
    
    // Check for Symbol.toPrimitive method
    const exoticToPrim = input[Symbol.toPrimitive];
    if (exoticToPrim !== undefined) {
        const result = exoticToPrim.call(input, preferredType);
        if (typeof result !== 'object') {
            return result;
        }
        throw new TypeError('Cannot convert object to primitive');
    }
    
    // Default conversion
    if (preferredType === 'string') {
        return input.toString();
    } else if (preferredType === 'number') {
        return input.valueOf();
    } else {
        return input.valueOf() || input.toString();
    }
}

// Custom toPrimitive
const obj = {
    [Symbol.toPrimitive](hint) {
        if (hint === 'number') return 42;
        if (hint === 'string') return 'hello';
        return true;
    }
};

console.log(Number(obj)); // 42
console.log(String(obj)); // "hello"
console.log(obj + '');    // "true"
```

#### **ToNumber**

Converts values to numbers:

```javascript
// ToNumber conversion rules
function toNumber(value) {
    const type = typeof value;
    
    switch (type) {
        case 'number': return value;
        case 'boolean': return value ? 1 : 0;
        case 'string': 
            // Strip whitespace
            const trimmed = value.trim();
            if (trimmed === '') return 0;
            // Try parsing as number
            const num = Number(trimmed);
            return isNaN(num) ? NaN : num;
        case 'symbol': 
        case 'bigint':
        case 'object': 
            throw new TypeError('Cannot convert to number');
        case 'undefined': return NaN;
        default: return 0;
    }
}

// Examples
console.log(toNumber(true));      // 1
console.log(toNumber(false));     // 0
console.log(toNumber('123'));     // 123
console.log(toNumber('123px'));   // NaN
console.log(toNumber(''));        // 0
console.log(toNumber(undefined)); // NaN
```

#### **ToString**

Converts values to strings:

```javascript
// ToString conversion rules
function toString(value) {
    const type = typeof value;
    
    switch (type) {
        case 'string': return value;
        case 'number': 
            if (value === 0) return '0';
            if (isNaN(value)) return 'NaN';
            if (value === Infinity) return 'Infinity';
            if (value === -Infinity) return '-Infinity';
            return value.toString();
        case 'boolean': return value ? 'true' : 'false';
        case 'symbol': 
            throw new TypeError('Cannot convert symbol to string');
        case 'bigint': return value.toString();
        case 'undefined': return 'undefined';
        case 'object': 
            if (value === null) return 'null';
            return toPrimitive(value, 'string').toString();
        default: return '';
    }
}

// Examples
console.log(toString(123));      // "123"
console.log(toString(true));      // "true"
console.log(toString(null));      // "null"
console.log(toString(undefined)); // "undefined"
```

## **Equality Comparison**

### **Loose Equality (==)**

The loose equality operator performs type coercion:

```javascript
// Abstract equality comparison algorithm
function abstractEquality(x, y) {
    const typeX = typeof x;
    const typeY = typeof y;
    
    // If types are the same, use strict equality
    if (typeX === typeY) {
        return strictEquality(x, y);
    }
    
    // Handle null and undefined
    if ((x === null && y === undefined) || (x === undefined && y === null)) {
        return true;
    }
    
    // Number and string
    if (typeX === 'number' && typeY === 'string') {
        return abstractEquality(x, toNumber(y));
    }
    if (typeX === 'string' && typeY === 'number') {
        return abstractEquality(toNumber(x), y);
    }
    
    // Boolean and any type
    if (typeX === 'boolean') {
        return abstractEquality(toNumber(x), y);
    }
    if (typeY === 'boolean') {
        return abstractEquality(x, toNumber(y));
    }
    
    // Object and primitive
    if ((typeX === 'object' && x !== null) || typeY === 'object' && y !== null) {
        if (typeX === 'object') {
            return abstractEquality(toPrimitive(x), y);
        } else {
            return abstractEquality(x, toPrimitive(y));
        }
    }
    
    return false;
}

// Examples of loose equality
console.log(0 == false);         // true
console.log('' == false);        // true
console.log('0' == false);       // true
console.log('0' == 0);           // true
console.log(null == undefined);  // true
console.log([] == false);        // true
console.log([1, 2] == '1,2');    // true
```

### **Strict Equality (===)**

Strict equality doesn't perform type coercion:

```javascript
// Strict equality comparison algorithm
function strictEquality(x, y) {
    const typeX = typeof x;
    const typeY = typeof y;
    
    // Different types are never equal
    if (typeX !== typeY) {
        return false;
    }
    
    // Handle different types
    switch (typeX) {
        case 'number':
            // Handle NaN case
            if (isNaN(x) && isNaN(y)) return false;
            return x === y;
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'symbol':
        case 'bigint':
            return x === y;
        case 'object':
            // Handle null case
            if (x === null && y === null) return true;
            if (x === null || y === null) return false;
            // For objects, compare references
            return x === y;
        default:
            return false;
    }
}

// Examples of strict equality
console.log(0 === false);        // false
console.log('0' === 0);          // false
console.log(null === undefined); // false
console.log([] === []);          // false (different references)
```

## **Operator Coercion**

### **Arithmetic Operators**

```javascript
// Addition operator coercion
function addition(x, y) {
    const primX = toPrimitive(x, 'default');
    const primY = toPrimitive(y, 'default');
    
    // If either operand is string, convert both to strings
    if (typeof primX === 'string' || typeof primY === 'string') {
        return toString(primX) + toString(primY);
    }
    
    // Otherwise, convert both to numbers
    return toNumber(primX) + toNumber(primY);
}

// Examples
console.log(1 + 2);           // 3 (number addition)
console.log('1' + 2);         // '12' (string concatenation)
console.log(1 + '2');         // '12' (string concatenation)
console.log(true + false);    // 1 (boolean to number)
console.log([] + {});         // '[object Object]' (both to string)
```

### **Comparison Operators**

```javascript
// Relational comparison coercion
function relationalComparison(x, y, operator) {
    const primX = toPrimitive(x, 'number');
    const primY = toPrimitive(y, 'number');
    
    // If both are strings, use string comparison
    if (typeof primX === 'string' && typeof primY === 'string') {
        switch (operator) {
            case '<': return primX < primY;
            case '>': return primX > primY;
            case '<=': return primX <= primY;
            case '>=': return primX >= primY;
        }
    }
    
    // Otherwise, convert to numbers
    const numX = toNumber(primX);
    const numY = toNumber(primY);
    
    switch (operator) {
        case '<': return numX < numY;
        case '>': return numX > numY;
        case '<=': return numX <= numY;
        case '>=': return numX >= numY;
    }
}

// Examples
console.log('2' > '10');       // true (string comparison)
console.log(2 > '10');         // false (number comparison)
console.log('a' > 'b');        // false (string comparison)
console.log([2] > [1]);        // true (converted to strings)
```

## **Advanced Type Checking**

### **Robust Type Checking**

```javascript
// Comprehensive type checking
function getType(value) {
    if (value === null) return 'null';
    
    const type = typeof value;
    
    if (type === 'object') {
        if (Array.isArray(value)) return 'array';
        if (value instanceof Date) return 'date';
        if (value instanceof RegExp) return 'regexp';
        if (value instanceof Map) return 'map';
        if (value instanceof Set) return 'set';
        if (value instanceof Promise) return 'promise';
        return 'object';
    }
    
    if (type === 'number') {
        if (isNaN(value)) return 'nan';
        if (!isFinite(value)) return 'infinity';
        return 'number';
    }
    
    return type;
}

// Usage
console.log(getType(null));           // 'null'
console.log(getType([1, 2, 3]));       // 'array'
console.log(getType(new Date()));      // 'date'
console.log(getType(/pattern/));       // 'regexp'
console.log(getType(NaN));             // 'nan'
console.log(getType(Infinity));        // 'infinity'
```

### **Type Guards and Predicates**

```javascript
// Type guard functions
const isNumber = (value) => 
    typeof value === 'number' && !isNaN(value) && isFinite(value);

const isInteger = (value) => 
    isNumber(value) && Number.isInteger(value);

const isString = (value) => 
    typeof value === 'string';

const isBoolean = (value) => 
    typeof value === 'boolean';

const isArray = (value) => 
    Array.isArray(value);

const isObject = (value) => 
    value !== null && typeof value === 'object' && !Array.isArray(value);

const isFunction = (value) => 
    typeof value === 'function';

const isPromise = (value) => 
    value instanceof Promise;

// Usage with type narrowing
function processValue(value) {
    if (isNumber(value)) {
        // TypeScript would know value is number here
        return value * 2;
    }
    
    if (isString(value)) {
        // TypeScript would know value is string here
        return value.toUpperCase();
    }
    
    if (isArray(value)) {
        // TypeScript would know value is array here
        return value.length;
    }
    
    return 'unknown type';
}
```

## **Custom Type Systems**

### **Runtime Type Checking**

```javascript
// Runtime type validation
class TypeValidator {
    static validate(value, schema) {
        if (schema.type === 'number') {
            if (typeof value !== 'number' || isNaN(value)) {
                return { valid: false, error: 'Expected number' };
            }
            if (schema.min !== undefined && value < schema.min) {
                return { valid: false, error: `Value must be >= ${schema.min}` };
            }
            if (schema.max !== undefined && value > schema.max) {
                return { valid: false, error: `Value must be <= ${schema.max}` };
            }
        }
        
        if (schema.type === 'string') {
            if (typeof value !== 'string') {
                return { valid: false, error: 'Expected string' };
            }
            if (schema.minLength !== undefined && value.length < schema.minLength) {
                return { valid: false, error: `String must be >= ${schema.minLength} characters` };
            }
            if (schema.maxLength !== undefined && value.length > schema.maxLength) {
                return { valid: false, error: `String must be <= ${schema.maxLength} characters` };
            }
            if (schema.pattern && !schema.pattern.test(value)) {
                return { valid: false, error: 'String does not match pattern' };
            }
        }
        
        if (schema.type === 'object') {
            if (!isObject(value)) {
                return { valid: false, error: 'Expected object' };
            }
            
            for (const [key, keySchema] of Object.entries(schema.properties || {})) {
                const result = this.validate(value[key], keySchema);
                if (!result.valid) {
                    return { valid: false, error: `Property ${key}: ${result.error}` };
                }
            }
        }
        
        if (schema.type === 'array') {
            if (!Array.isArray(value)) {
                return { valid: false, error: 'Expected array' };
            }
            
            if (schema.itemSchema) {
                for (let i = 0; i < value.length; i++) {
                    const result = this.validate(value[i], schema.itemSchema);
                    if (!result.valid) {
                        return { valid: false, error: `Item ${i}: ${result.error}` };
                    }
                }
            }
        }
        
        return { valid: true };
    }
}

// Usage
const userSchema = {
    type: 'object',
    properties: {
        name: { type: 'string', minLength: 1 },
        age: { type: 'number', min: 0, max: 150 },
        email: { type: 'string', pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ }
    }
};

const user = { name: 'John', age: 25, email: 'john@example.com' };
const validation = TypeValidator.validate(user, userSchema);
console.log(validation); // { valid: true }
```

### **Type-safe Function Composition**

```javascript
// Type-safe function composition
function composeTypesafe(...fns) {
    return function(input) {
        let result = input;
        let currentType = typeof input;
        
        for (const fn of fns) {
            // Validate input type matches function expectation
            if (fn.inputType && currentType !== fn.inputType) {
                throw new TypeError(`Expected ${fn.inputType}, got ${currentType}`);
            }
            
            result = fn(result);
            currentType = fn.outputType || typeof result;
        }
        
        return result;
    };
}

// Typed functions
const addOne = {
    fn: (x) => x + 1,
    inputType: 'number',
    outputType: 'number'
};

const toString = {
    fn: (x) => x.toString(),
    inputType: 'number',
    outputType: 'string'
};

const toUpperCase = {
    fn: (x) => x.toUpperCase(),
    inputType: 'string',
    outputType: 'string'
};

const pipeline = composeTypesafe(addOne.fn, toString.fn, toUpperCase.fn);
console.log(pipeline(5)); // "6"
```

## **Advanced Type Coercion Patterns**

### **Safe Coercion Utilities**

```javascript
// Safe coercion utilities
class SafeCoercion {
    static toNumber(value, defaultValue = 0) {
        const num = Number(value);
        return isNaN(num) ? defaultValue : num;
    }
    
    static toInteger(value, defaultValue = 0) {
        const num = Number(value);
        if (isNaN(num)) return defaultValue;
        return Math.trunc(num);
    }
    
    static toBoolean(value) {
        if (typeof value === 'boolean') return value;
        if (typeof value === 'number') return value !== 0 && !isNaN(value);
        if (typeof value === 'string') return value.trim() !== '' && value !== '0';
        if (value === null || value === undefined) return false;
        return true;
    }
    
    static toString(value, defaultValue = '') {
        if (value === null || value === undefined) return defaultValue;
        return String(value);
    }
    
    static toArray(value) {
        if (Array.isArray(value)) return value;
        if (value === null || value === undefined) return [];
        return [value];
    }
}

// Usage
console.log(SafeCoercion.toNumber('123', 0));      // 123
console.log(SafeCoercion.toNumber('abc', 0));      // 0
console.log(SafeCoercion.toBoolean(1));            // true
console.log(SafeCoercion.toBoolean(0));            // false
console.log(SafeCoercion.toBoolean('true'));       // true
console.log(SafeCoercion.toArray([1, 2, 3]));      // [1, 2, 3]
console.log(SafeCoercion.toArray(42));             // [42]
```

### **Type Conversion with Validation**

```javascript
// Type conversion with validation
class TypeConverter {
    static convertWithValidation(value, targetType, options = {}) {
        try {
            switch (targetType) {
                case 'number':
                    return this.toNumber(value, options);
                case 'string':
                    return this.toString(value, options);
                case 'boolean':
                    return this.toBoolean(value, options);
                case 'integer':
                    return this.toInteger(value, options);
                default:
                    throw new Error(`Unsupported target type: ${targetType}`);
            }
        } catch (error) {
            if (options.defaultValue !== undefined) {
                return options.defaultValue;
            }
            throw error;
        }
    }
    
    static toNumber(value, options = {}) {
        const num = Number(value);
        if (isNaN(num)) {
            throw new Error('Cannot convert to number');
        }
        
        if (options.min !== undefined && num < options.min) {
            throw new Error(`Value ${num} is below minimum ${options.min}`);
        }
        
        if (options.max !== undefined && num > options.max) {
            throw new Error(`Value ${num} is above maximum ${options.max}`);
        }
        
        return num;
    }
    
    static toInteger(value, options = {}) {
        const num = Number(value);
        if (isNaN(num)) {
            throw new Error('Cannot convert to integer');
        }
        
        const integer = Math.trunc(num);
        if (options.min !== undefined && integer < options.min) {
            throw new Error(`Value ${integer} is below minimum ${options.min}`);
        }
        
        if (options.max !== undefined && integer > options.max) {
            throw new Error(`Value ${integer} is above maximum ${options.max}`);
        }
        
        return integer;
    }
    
    static toString(value, options = {}) {
        const str = String(value);
        
        if (options.minLength !== undefined && str.length < options.minLength) {
            throw new Error(`String length ${str.length} is below minimum ${options.minLength}`);
        }
        
        if (options.maxLength !== undefined && str.length > options.maxLength) {
            throw new Error(`String length ${str.length} is above maximum ${options.maxLength}`);
        }
        
        if (options.pattern && !options.pattern.test(str)) {
            throw new Error('String does not match required pattern');
        }
        
        return str;
    }
    
    static toBoolean(value) {
        if (typeof value === 'boolean') return value;
        if (typeof value === 'number') return value !== 0 && !isNaN(value);
        if (typeof value === 'string') {
            const lower = value.toLowerCase().trim();
            if (lower === 'true' || lower === '1') return true;
            if (lower === 'false' || lower === '0') return false;
            throw new Error('Cannot convert string to boolean');
        }
        throw new Error('Cannot convert to boolean');
    }
}

// Usage
try {
    const age = TypeConverter.convertWithValidation('25', 'integer', { min: 0, max: 150 });
    console.log(age); // 25
    
    const invalid = TypeConverter.convertWithValidation('abc', 'number');
} catch (error) {
    console.error(error.message); // "Cannot convert to number"
}
```

This comprehensive coverage of advanced type system concepts and coercion rules provides a deep understanding of JavaScript's type behavior, which is essential for writing robust and predictable code.